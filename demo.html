<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Starfox 64 Style Player Controller - Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a1a;
      color: #e0e0e0;
      overflow-x: hidden;
    }
    
    .demo-container {
      width: 100%;
      min-height: 100vh;
    }
    
    #game-canvas {
      width: 100%;
      height: 70vh;
      min-height: 500px;
      background: #000011;
      position: relative;
      cursor: crosshair;
    }
    
    #game-canvas canvas {
      display: block;
    }
    
    /* HUD Overlay */
    #hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      font-family: 'Courier New', monospace;
      color: #00ff88;
      text-shadow: 0 0 10px #00ff88;
    }
    
    .hud-speed {
      position: absolute;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .hud-speed .label {
      font-size: 14px;
      margin-bottom: 5px;
    }
    
    .hud-speed .bar-container {
      width: 20px;
      height: 200px;
      border: 2px solid #00ff88;
      position: relative;
    }
    
    .hud-speed .bar-fill {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: #00ff88;
      transition: height 0.1s, background 0.1s;
    }
    
    .hud-speed .value {
      font-size: 12px;
      margin-top: 5px;
    }
    
    .hud-meter {
      position: absolute;
      right: 20px;
    }
    
    .hud-boost { top: 20px; }
    .hud-dodge { top: 90px; }
    
    .hud-meter .label {
      font-size: 14px;
      margin-bottom: 5px;
    }
    
    .hud-meter .bar-container {
      width: 150px;
      height: 15px;
      border: 2px solid #00ff88;
      position: relative;
    }
    
    .hud-meter .bar-fill {
      height: 100%;
      transition: width 0.1s, background 0.1s;
    }
    
    .hud-meter .hint {
      font-size: 10px;
      margin-top: 2px;
      opacity: 0.7;
    }
    
    .hud-controls {
      position: absolute;
      left: 20px;
      bottom: 20px;
      font-size: 11px;
      opacity: 0.7;
    }
    
    .hud-controls div {
      margin: 3px 0;
    }
    
    .hud-position {
      position: absolute;
      right: 20px;
      bottom: 20px;
      font-size: 12px;
      text-align: right;
    }
    
    .hud-crosshair {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #00ff88;
      box-shadow: 0 0 10px #00ff88;
    }
    
    .hud-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -80px);
      font-size: 24px;
      text-align: center;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .hud-message.visible {
      opacity: 1;
    }
    
    /* Info panel */
    .info-panel {
      padding: 30px;
      background: linear-gradient(180deg, #0d0d20 0%, #0a0a1a 100%);
      border-top: 1px solid #1a1a3a;
    }
    
    .info-panel h1 {
      font-size: 2em;
      color: #00ff88;
      text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
      margin-bottom: 10px;
    }
    
    .info-panel h2 {
      font-size: 1.3em;
      color: #4488ff;
      margin: 25px 0 15px 0;
      border-bottom: 1px solid #2a2a4a;
      padding-bottom: 8px;
    }
    
    .subtitle {
      color: #888;
      font-size: 1.1em;
      margin-bottom: 25px;
    }
    
    .features-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    
    .feature-card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid #2a2a4a;
      border-radius: 8px;
      padding: 20px;
      transition: all 0.3s ease;
    }
    
    .feature-card:hover {
      border-color: #00ff88;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.1);
    }
    
    .feature-card h3 {
      color: #00ff88;
      margin-bottom: 10px;
    }
    
    .feature-card p {
      color: #aaa;
      line-height: 1.6;
    }
    
    .controls-table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
    }
    
    .controls-table th,
    .controls-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #2a2a4a;
    }
    
    .controls-table th {
      color: #00ff88;
      font-weight: 600;
    }
    
    .controls-table td:first-child {
      color: #4488ff;
      font-family: 'Courier New', monospace;
    }
    
    .key-badge {
      display: inline-block;
      background: #1a1a3a;
      border: 1px solid #3a3a5a;
      border-radius: 4px;
      padding: 3px 8px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      margin: 2px;
    }
    
    .config-section {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
    }
    
    .config-section pre {
      background: #0d0d1a;
      border: 1px solid #2a2a4a;
      border-radius: 4px;
      padding: 15px;
      overflow-x: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      line-height: 1.5;
      color: #00ff88;
    }
    
    footer {
      text-align: center;
      padding: 30px;
      color: #666;
      border-top: 1px solid #1a1a3a;
    }
  </style>
</head>
<body>
  <div class="demo-container">
    <!-- Game Canvas -->
    <div id="game-canvas">
      <!-- HUD Overlay -->
      <div id="hud">
        <div class="hud-speed">
          <div class="label">SPEED</div>
          <div class="bar-container">
            <div class="bar-fill" id="speed-bar"></div>
          </div>
          <div class="value" id="speed-value">15</div>
        </div>
        
        <div class="hud-meter hud-boost">
          <div class="label" id="boost-label">BOOST [READY]</div>
          <div class="bar-container">
            <div class="bar-fill" id="boost-bar" style="width: 100%; background: #00ff88;"></div>
          </div>
          <div class="hint">SHIFT / RT</div>
        </div>
        
        <div class="hud-meter hud-dodge">
          <div class="label" id="dodge-label">BARREL ROLL [READY]</div>
          <div class="bar-container">
            <div class="bar-fill" id="dodge-bar" style="width: 100%; background: #00ff88;"></div>
          </div>
          <div class="hint">SPACE / LB</div>
        </div>
        
        <div class="hud-controls">
          <div>WASD / L-Stick: Move</div>
          <div>Mouse / R-Stick: Aim</div>
          <div>Click / LT: Fire</div>
          <div>SHIFT / RT: Boost</div>
          <div>SPACE / LB: Barrel Roll</div>
        </div>
        
        <div class="hud-position">
          <div id="pos-x">X: 0.0</div>
          <div id="pos-y">Y: 0.0</div>
          <div id="pos-z">Z: 0.0</div>
        </div>
        
        <div class="hud-crosshair"></div>
        
        <div class="hud-message" id="hud-message"></div>
      </div>
    </div>
    
    <!-- Info Panel -->
    <div class="info-panel">
      <h1>‚ö° Starfox 64 Style Player Controller</h1>
      <p class="subtitle">A Three.js implementation of classic rail shooter mechanics</p>
      
      <h2>üéÆ Controls</h2>
      <table class="controls-table">
        <thead>
          <tr>
            <th>Action</th>
            <th>Keyboard</th>
            <th>Gamepad</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Move Ship</td>
            <td>
              <span class="key-badge">W</span>
              <span class="key-badge">A</span>
              <span class="key-badge">S</span>
              <span class="key-badge">D</span>
            </td>
            <td>Left Stick</td>
          </tr>
          <tr>
            <td>Aim Reticle</td>
            <td>Mouse Movement</td>
            <td>Right Stick</td>
          </tr>
          <tr>
            <td>Fire Weapon</td>
            <td><span class="key-badge">Left Click</span></td>
            <td>LT (Left Trigger)</td>
          </tr>
          <tr>
            <td>Boost</td>
            <td><span class="key-badge">Shift</span></td>
            <td>RT (Right Trigger)</td>
          </tr>
          <tr>
            <td>Barrel Roll</td>
            <td>
              <span class="key-badge">Space</span> or
              <span class="key-badge">E</span>
            </td>
            <td>LB / RB</td>
          </tr>
        </tbody>
      </table>
      
      <h2>‚ú® Features</h2>
      <div class="features-grid">
        <div class="feature-card">
          <h3>üõ§Ô∏è Spline-Based Movement</h3>
          <p>Ship follows an invisible CatmullRom spline path while player controls lateral and vertical offset. Provides the classic "on-rails" feel of Starfox.</p>
        </div>
        <div class="feature-card">
          <h3>üöÄ Boost System</h3>
          <p>Temporary speed increase (15 ‚Üí 35 units/s) lasting 2 seconds with a 5-second cooldown. Visual feedback includes engine glow and ship color change.</p>
        </div>
        <div class="feature-card">
          <h3>üîÑ Barrel Roll / Dodge</h3>
          <p>Performs a 360¬∞ roll animation with temporary invulnerability and 1.8x agility multiplier. 600ms duration with 3-second cooldown.</p>
        </div>
        <div class="feature-card">
          <h3>üéØ Aiming System</h3>
          <p>Independent reticle control via mouse or right stick. Projectiles fire from ship position toward reticle location with rapid-fire capability.</p>
        </div>
        <div class="feature-card">
          <h3>üéÆ Gamepad Support</h3>
          <p>Full controller support with analog stick input, deadzone handling, and button mapping for all actions. Automatically detected.</p>
        </div>
        <div class="feature-card">
          <h3>üìä HUD Overlay</h3>
          <p>Real-time display of speed, boost meter, dodge cooldown, and position coordinates using HTML overlay system.</p>
        </div>
      </div>
      
      <h2>‚öôÔ∏è Configuration</h2>
      <div class="config-section">
        <pre>const CONFIG = {
  // Movement
  MOVE_SPEED: 8,              // Lateral movement speed
  MOVE_BOUNDS: { x: 12, y: 8 }, // Movement area limits
  FORWARD_SPEED: 15,          // Base forward speed
  BOOST_SPEED: 35,            // Speed during boost
  BOOST_DURATION: 2000,       // Boost length (ms)
  BOOST_COOLDOWN: 5000,       // Time between boosts (ms)
  
  // Dodge/Barrel Roll
  DODGE_DURATION: 600,        // Roll animation length (ms)
  DODGE_COOLDOWN: 3000,       // Time between dodges (ms)
  DODGE_AGILITY_MULT: 1.8,    // Movement multiplier during dodge
  
  // Weapons
  FIRE_RATE: 100,             // Min ms between shots
  PROJECTILE_SPEED: 80,       // Projectile velocity
  PROJECTILE_LIFETIME: 2000,  // Max projectile lifespan (ms)
};</pre>
      </div>
    </div>
    
    <footer>
      <p>Starfox 64 Style Player Controller ‚Ä¢ Built with Three.js</p>
    </footer>
  </div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    // ========================================================================
    // CONFIGURATION
    // ========================================================================
    const CONFIG = {
      MOVE_SPEED: 8,
      MOVE_BOUNDS: { x: 12, y: 8 },
      FORWARD_SPEED: 15,
      BOOST_SPEED: 35,
      BOOST_DURATION: 2000,
      BOOST_COOLDOWN: 5000,
      DODGE_DURATION: 600,
      DODGE_COOLDOWN: 3000,
      DODGE_AGILITY_MULT: 1.8,
      FIRE_RATE: 100,
      PROJECTILE_SPEED: 80,
      PROJECTILE_LIFETIME: 2000,
      SHIP_TILT_FACTOR: 0.3,
      RETICLE_DISTANCE: 50,
    };

    // ========================================================================
    // INPUT MANAGER
    // ========================================================================
    class InputManager {
      constructor() {
        this.keys = {
          up: false, down: false, left: false, right: false,
          boost: false, dodge: false, fire: false
        };
        this.mouse = { x: 0, y: 0 };
        this.gamepad = {
          leftStick: { x: 0, y: 0 },
          rightStick: { x: 0, y: 0 },
          buttons: {}
        };
        
        this.setupEventListeners();
      }
      
      setupEventListeners() {
        const keyMap = {
          'KeyW': 'up', 'ArrowUp': 'up',
          'KeyS': 'down', 'ArrowDown': 'down',
          'KeyA': 'left', 'ArrowLeft': 'left',
          'KeyD': 'right', 'ArrowRight': 'right',
          'ShiftLeft': 'boost', 'ShiftRight': 'boost',
          'Space': 'dodge', 'KeyE': 'dodge',
        };
        
        window.addEventListener('keydown', (e) => {
          const action = keyMap[e.code];
          if (action) {
            this.keys[action] = true;
            e.preventDefault();
          }
        });
        
        window.addEventListener('keyup', (e) => {
          const action = keyMap[e.code];
          if (action) this.keys[action] = false;
        });
        
        const canvas = document.getElementById('game-canvas');
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        });
        
        canvas.addEventListener('mousedown', (e) => {
          if (e.button === 0) this.keys.fire = true;
        });
        
        canvas.addEventListener('mouseup', (e) => {
          if (e.button === 0) this.keys.fire = false;
        });
        
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
      }
      
      pollGamepad() {
        try {
          const gamepads = navigator.getGamepads();
          const gp = gamepads[0];
          if (gp) {
            this.gamepad = {
              leftStick: { x: gp.axes[0] || 0, y: gp.axes[1] || 0 },
              rightStick: { x: gp.axes[2] || 0, y: gp.axes[3] || 0 },
              buttons: {
                boost: gp.buttons[7]?.pressed || false,
                dodge: gp.buttons[4]?.pressed || gp.buttons[5]?.pressed || false,
                fire: gp.buttons[6]?.pressed || false,
              }
            };
          }
        } catch (e) {
          // Gamepad API not available in this context (sandboxed iframe)
          // Keyboard/mouse controls will still work
        }
      }
      
      applyDeadzone(val, deadzone = 0.15) {
        return Math.abs(val) < deadzone ? 0 : val;
      }
      
      getInput() {
        this.pollGamepad();
        const gp = this.gamepad;
        
        return {
          moveX: this.applyDeadzone(gp.leftStick.x) || (this.keys.left ? -1 : this.keys.right ? 1 : 0),
          moveY: this.applyDeadzone(-gp.leftStick.y) || (this.keys.up ? 1 : this.keys.down ? -1 : 0),
          aimX: this.applyDeadzone(gp.rightStick.x) || this.mouse.x,
          aimY: this.applyDeadzone(-gp.rightStick.y) || this.mouse.y,
          boost: this.keys.boost || gp.buttons.boost || false,
          dodge: this.keys.dodge || gp.buttons.dodge || false,
          fire: this.keys.fire || gp.buttons.fire || false,
        };
      }
    }

    // ========================================================================
    // GAME CLASS
    // ========================================================================
    class StarfoxGame {
      constructor(container) {
        this.container = container;
        this.projectiles = [];
        this.splineProgress = 0;
        this.localOffset = { x: 0, y: 0 };
        
        // State
        this.boostCooldown = 0;
        this.boostActive = false;
        this.boostStartTime = 0;
        this.dodgeCooldown = 0;
        this.isRolling = false;
        this.rollProgress = 0;
        this.dodgeStartTime = 0;
        this.isInvulnerable = false;
        this.currentSpeed = CONFIG.FORWARD_SPEED;
        this.lastFireTime = 0;
        
        // Ship rotation tracking
        this.shipRotation = { x: 0, z: 0 };
        
        this.init();
      }
      
      init() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.Fog(0x000022, 50, 200);
        
        // Camera
        this.camera = new THREE.PerspectiveCamera(
          75,
          this.container.clientWidth / this.container.clientHeight,
          0.1,
          1000
        );
        this.camera.position.set(0, 5, 15);
        
        // Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.setClearColor(0x000011);
        this.container.insertBefore(this.renderer.domElement, this.container.firstChild);
        
        // Input
        this.input = new InputManager();
        
        // Create spline
        this.createSpline();
        
        // Create scene objects
        this.createLighting();
        this.createShip();
        this.createReticle();
        this.createTerrain();
        
        // Handle resize
        window.addEventListener('resize', () => this.onResize());
        
        // Start game loop
        this.lastTime = performance.now();
        this.animate();
      }
      
      createSpline() {
        const points = [
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 2, -100),
          new THREE.Vector3(10, 5, -200),
          new THREE.Vector3(-5, 3, -300),
          new THREE.Vector3(0, 8, -400),
          new THREE.Vector3(15, 4, -500),
          new THREE.Vector3(-10, 6, -600),
          new THREE.Vector3(0, 2, -700),
          new THREE.Vector3(5, 10, -800),
          new THREE.Vector3(0, 5, -1000),
        ];
        this.spline = new THREE.CatmullRomCurve3(points, false, 'catmullrom', 0.5);
        this.splineLength = this.spline.getLength();
      }
      
      createLighting() {
        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(ambient);
        
        const directional = new THREE.DirectionalLight(0xffffff, 1);
        directional.position.set(10, 20, 10);
        this.scene.add(directional);
      }
      
      createShip() {
        this.shipGroup = new THREE.Group();
        this.shipRollGroup = new THREE.Group();
        
        // Main body
        const bodyGeometry = new THREE.BoxGeometry(1.5, 0.5, 2);
        this.bodyMaterial = new THREE.MeshStandardMaterial({
          color: 0x4488ff,
          emissive: 0x112244,
          metalness: 0.8,
          roughness: 0.2,
        });
        const body = new THREE.Mesh(bodyGeometry, this.bodyMaterial);
        this.shipRollGroup.add(body);
        
        // Wings
        const wingGeometry = new THREE.BoxGeometry(1.5, 0.1, 1);
        const wingMaterial = new THREE.MeshStandardMaterial({
          color: 0x3366cc,
          metalness: 0.8,
          roughness: 0.2,
        });
        
        const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
        leftWing.position.set(-1.5, 0, 0);
        this.shipRollGroup.add(leftWing);
        
        const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
        rightWing.position.set(1.5, 0, 0);
        this.shipRollGroup.add(rightWing);
        
        // Cockpit
        const cockpitGeometry = new THREE.SphereGeometry(0.3, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        const cockpitMaterial = new THREE.MeshStandardMaterial({
          color: 0x88ccff,
          transparent: true,
          opacity: 0.7,
        });
        const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
        cockpit.position.set(0, 0.3, -0.3);
        this.shipRollGroup.add(cockpit);
        
        // Engine
        const engineGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
        this.engineMaterial = new THREE.MeshBasicMaterial({ color: 0xff8800 });
        this.engine = new THREE.Mesh(engineGeometry, this.engineMaterial);
        this.engine.position.set(0, 0, 1.2);
        this.shipRollGroup.add(this.engine);
        
        // Engine light
        this.engineLight = new THREE.PointLight(0xff8800, 2, 4);
        this.engineLight.position.set(0, 0, 1.5);
        this.shipRollGroup.add(this.engineLight);
        
        this.shipGroup.add(this.shipRollGroup);
        this.shipGroup.rotation.y = Math.PI;
        this.scene.add(this.shipGroup);
      }
      
      createReticle() {
        this.reticleGroup = new THREE.Group();
        
        // Outer ring
        const outerGeometry = new THREE.RingGeometry(0.8, 1, 4);
        const reticleMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide,
        });
        const outer = new THREE.Mesh(outerGeometry, reticleMaterial);
        this.reticleGroup.add(outer);
        
        // Inner ring
        const innerGeometry = new THREE.RingGeometry(0.5, 0.6, 4);
        const inner = new THREE.Mesh(innerGeometry, reticleMaterial.clone());
        inner.material.opacity = 0.6;
        inner.rotation.z = Math.PI / 4;
        this.reticleGroup.add(inner);
        
        this.scene.add(this.reticleGroup);
      }
      
      createTerrain() {
        const points = this.spline.getPoints(100);
        
        // Ground planes
        const planeGeometry = new THREE.PlaneGeometry(60, 15);
        const planeMaterial = new THREE.MeshStandardMaterial({
          color: 0x224422,
          transparent: true,
          opacity: 0.3,
        });
        
        for (let i = 0; i < points.length; i += 5) {
          const plane = new THREE.Mesh(planeGeometry, planeMaterial);
          plane.position.set(points[i].x, points[i].y - 15, points[i].z);
          plane.rotation.x = -Math.PI / 2;
          this.scene.add(plane);
        }
        
        // Spline line visualization
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const lineMaterial = new THREE.LineBasicMaterial({
          color: 0x444488,
          transparent: true,
          opacity: 0.3,
        });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        this.scene.add(line);
      }
      
      fireProjectile() {
        const now = performance.now();
        if (now - this.lastFireTime < CONFIG.FIRE_RATE) return;
        this.lastFireTime = now;
        
        const shipPos = this.shipGroup.position.clone();
        const reticlePos = this.reticleGroup.position.clone();
        const direction = new THREE.Vector3().subVectors(reticlePos, shipPos).normalize();
        
        // Create projectile
        const geometry = new THREE.SphereGeometry(0.15, 8, 8);
        const material = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
        const projectile = new THREE.Mesh(geometry, material);
        projectile.position.copy(shipPos);
        
        // Add light to projectile
        const light = new THREE.PointLight(0x00ff88, 2, 5);
        projectile.add(light);
        
        this.scene.add(projectile);
        this.projectiles.push({
          mesh: projectile,
          direction: direction,
          startTime: now,
        });
      }
      
      updateProjectiles(delta) {
        const now = performance.now();
        
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
          const proj = this.projectiles[i];
          
          // Move projectile
          proj.mesh.position.add(
            proj.direction.clone().multiplyScalar(CONFIG.PROJECTILE_SPEED * delta)
          );
          
          // Remove if expired
          if (now - proj.startTime > CONFIG.PROJECTILE_LIFETIME) {
            this.scene.remove(proj.mesh);
            proj.mesh.geometry.dispose();
            proj.mesh.material.dispose();
            this.projectiles.splice(i, 1);
          }
        }
      }
      
      showMessage(text, duration = 1000) {
        const msg = document.getElementById('hud-message');
        msg.textContent = text;
        msg.classList.add('visible');
        setTimeout(() => msg.classList.remove('visible'), duration);
      }
      
      updateHUD() {
        const speedPercent = (this.currentSpeed / CONFIG.BOOST_SPEED) * 100;
        document.getElementById('speed-bar').style.height = `${speedPercent}%`;
        document.getElementById('speed-bar').style.background = this.boostActive ? '#ff4400' : '#00ff88';
        document.getElementById('speed-value').textContent = Math.round(this.currentSpeed);
        
        const boostPercent = Math.max(0, 100 - (this.boostCooldown / CONFIG.BOOST_COOLDOWN) * 100);
        document.getElementById('boost-bar').style.width = `${boostPercent}%`;
        document.getElementById('boost-bar').style.background = 
          this.boostActive ? '#ff4400' : boostPercent >= 100 ? '#00ff88' : '#448844';
        document.getElementById('boost-label').textContent = 
          `BOOST ${this.boostActive ? '[ACTIVE]' : boostPercent >= 100 ? '[READY]' : ''}`;
        
        const dodgePercent = Math.max(0, 100 - (this.dodgeCooldown / CONFIG.DODGE_COOLDOWN) * 100);
        document.getElementById('dodge-bar').style.width = `${dodgePercent}%`;
        document.getElementById('dodge-bar').style.background = 
          this.isInvulnerable ? '#88ffff' : dodgePercent >= 100 ? '#00ff88' : '#448844';
        document.getElementById('dodge-label').textContent = 
          `BARREL ROLL ${this.isInvulnerable ? '[ROLLING]' : dodgePercent >= 100 ? '[READY]' : ''}`;
        
        const pos = this.shipGroup.position;
        document.getElementById('pos-x').textContent = `X: ${pos.x.toFixed(1)}`;
        document.getElementById('pos-y').textContent = `Y: ${pos.y.toFixed(1)}`;
        document.getElementById('pos-z').textContent = `Z: ${pos.z.toFixed(1)}`;
      }
      
      lerp(a, b, t) {
        return a + (b - a) * t;
      }
      
      clamp(val, min, max) {
        return Math.max(min, Math.min(max, val));
      }
      
      update(delta) {
        const now = performance.now();
        const input = this.input.getInput();
        
        // Update cooldowns
        if (this.boostCooldown > 0) {
          this.boostCooldown = Math.max(0, this.boostCooldown - delta * 1000);
        }
        if (this.dodgeCooldown > 0) {
          this.dodgeCooldown = Math.max(0, this.dodgeCooldown - delta * 1000);
        }
        
        // Handle boost
        if (input.boost && this.boostCooldown === 0 && !this.boostActive) {
          this.boostActive = true;
          this.boostStartTime = now;
          this.showMessage('BOOST!');
        }
        
        if (this.boostActive && now - this.boostStartTime > CONFIG.BOOST_DURATION) {
          this.boostActive = false;
          this.boostCooldown = CONFIG.BOOST_COOLDOWN;
        }
        
        // Handle dodge/barrel roll
        if (input.dodge && this.dodgeCooldown === 0 && !this.isRolling) {
          this.isRolling = true;
          this.isInvulnerable = true;
          this.dodgeStartTime = now;
          this.rollProgress = 0;
          this.showMessage('DO A BARREL ROLL!');
        }
        
        if (this.isRolling) {
          const progress = Math.min((now - this.dodgeStartTime) / CONFIG.DODGE_DURATION, 1);
          this.rollProgress = progress;
          
          if (progress >= 1) {
            this.isRolling = false;
            this.isInvulnerable = false;
            this.dodgeCooldown = CONFIG.DODGE_COOLDOWN;
          }
        }
        
        // Calculate speed
        this.currentSpeed = this.boostActive ? CONFIG.BOOST_SPEED : CONFIG.FORWARD_SPEED;
        
        // Update spline progress
        const progressDelta = (this.currentSpeed * delta) / this.splineLength;
        this.splineProgress += progressDelta;
        if (this.splineProgress >= 1) this.splineProgress = 0;
        
        // Get spline position
        const splinePos = this.spline.getPointAt(Math.min(this.splineProgress, 0.999));
        
        // Update local offset
        const agilityMult = this.isRolling ? CONFIG.DODGE_AGILITY_MULT : 1;
        this.localOffset.x = this.clamp(
          this.localOffset.x + input.moveX * CONFIG.MOVE_SPEED * delta * agilityMult,
          -CONFIG.MOVE_BOUNDS.x,
          CONFIG.MOVE_BOUNDS.x
        );
        this.localOffset.y = this.clamp(
          this.localOffset.y + input.moveY * CONFIG.MOVE_SPEED * delta * agilityMult,
          -CONFIG.MOVE_BOUNDS.y,
          CONFIG.MOVE_BOUNDS.y
        );
        
        // Update ship position
        this.shipGroup.position.set(
          splinePos.x + this.localOffset.x,
          splinePos.y + this.localOffset.y,
          splinePos.z
        );
        
        // Update ship rotation (tilt)
        const targetRotX = -input.moveY * CONFIG.SHIP_TILT_FACTOR;
        const targetRotZ = input.moveX * CONFIG.SHIP_TILT_FACTOR * 1.5;
        this.shipRotation.x = this.lerp(this.shipRotation.x, targetRotX, 0.1);
        this.shipRotation.z = this.lerp(this.shipRotation.z, targetRotZ, 0.1);
        this.shipGroup.rotation.x = this.shipRotation.x;
        this.shipGroup.rotation.z = this.shipRotation.z;
        
        // Update roll
        this.shipRollGroup.rotation.z = this.isRolling ? this.rollProgress * Math.PI * 2 : 0;
        
        // Update ship visuals based on state
        if (this.isInvulnerable) {
          this.bodyMaterial.color.setHex(0x88ffff);
          this.bodyMaterial.emissive.setHex(0x448888);
        } else if (this.boostActive) {
          this.bodyMaterial.color.setHex(0xff8844);
          this.bodyMaterial.emissive.setHex(0x442200);
        } else {
          this.bodyMaterial.color.setHex(0x4488ff);
          this.bodyMaterial.emissive.setHex(0x112244);
        }
        
        // Update engine
        this.engine.scale.y = this.boostActive ? 2.5 : 1;
        this.engineMaterial.color.setHex(this.boostActive ? 0xff4400 : 0xff8800);
        this.engineLight.color.setHex(this.boostActive ? 0xff4400 : 0xff8800);
        this.engineLight.intensity = this.boostActive ? 5 : 2;
        this.engineLight.distance = this.boostActive ? 8 : 4;
        
        // Update reticle position
        this.reticleGroup.position.set(
          this.shipGroup.position.x + input.aimX * 15,
          this.shipGroup.position.y + input.aimY * 10,
          this.shipGroup.position.z - CONFIG.RETICLE_DISTANCE
        );
        this.reticleGroup.rotation.z += delta * 2;
        
        // Handle firing
        if (input.fire) {
          this.fireProjectile();
        }
        
        // Update projectiles
        this.updateProjectiles(delta);
        
        // Update camera
        const targetCamX = this.shipGroup.position.x;
        const targetCamY = this.shipGroup.position.y + 5;
        const targetCamZ = this.shipGroup.position.z + 15;
        
        this.camera.position.x = this.lerp(this.camera.position.x, targetCamX, 0.05);
        this.camera.position.y = this.lerp(this.camera.position.y, targetCamY, 0.05);
        this.camera.position.z = this.lerp(this.camera.position.z, targetCamZ, 0.05);
        
        this.camera.lookAt(
          this.shipGroup.position.x,
          this.shipGroup.position.y,
          this.shipGroup.position.z - 20
        );
        
        // Update HUD
        this.updateHUD();
      }
      
      animate() {
        requestAnimationFrame(() => this.animate());
        
        const now = performance.now();
        const delta = Math.min((now - this.lastTime) / 1000, 0.1);
        this.lastTime = now;
        
        this.update(delta);
        this.renderer.render(this.scene, this.camera);
      }
      
      onResize() {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
      }
    }

    // ========================================================================
    // INITIALIZE GAME
    // ========================================================================
    window.addEventListener('DOMContentLoaded', () => {
      const container = document.getElementById('game-canvas');
      const game = new StarfoxGame(container);
      
      // Click to focus
      container.addEventListener('click', () => {
        container.focus();
      });
    });
  </script>
</body>
</html>
